## プリミティブ型

### 数値(Number)

JavaScriptでは、もちろん計算もできます。
ただし全ての数字に関して計算が電卓で行ったように結果が出るかというと、実は「あること」が関係しているため、そうもいかないことがあります。

試しに以下の内容をGoogle developer tool を開いて、Consoleタブで計算してみましょう。

```js
const a = 0.1 + 0.2;
console.log(a);
```

単純に 0.1 + 0.2 の答えは電卓や暗算で行うと、もちろん 0.3 になるはずです。
ところが、JavaScriptの計算結果では以下のようになります。

```
0.30000000000000004
```

なぜでしょうか？
実はJavaScriptで適用される数値の表現は、**IEEE 754-2008**という**倍精度浮動小数点数（64ビット）**の表現を使用するために、計算結果が上記のようになるケースもあります。

もっと具体的に解説していきます。
数値の中にはコンピューターで表現できるものとできないもの（πなど）があるため、表現できないものは**近似値**で表現されます。
近似値で表現された数値の計算なので、組み合わせによって計算ミスのような結果が出る場合もあるのです。

別の例でいうと、πなどの無限にある桁数の数値と、限りのある有限の数値を計算することはできないので、コンピューターで表現できる近似値に無限にある数値を当てはめるため、こうしたことが起こります。

```
※  さらに踏み込むとJavaScriptは、他の言語と少し異なる点があり、整数と浮動小数点数を区別せず、全ての数値を浮動小数点数で表します。
```

そのため、JavaScriptは電卓アプリなど、整数演算や固定小数点数の精度が求められるアプリの開発には不向きだということがわかります。

特殊な例として、以下のような値も結果として返ってくる場合があります。

```js
console.log(1/0);// 計算結果 --> Infinity (無限大)
console.log(-1/0);// 計算結果 --> -Infinity（負の無限大）
console.log(Infinity/Infinity);// 計算結果 --> NaN（Not a numberの略）
```

計算結果としてこのような値が返ってくることもありますので、見慣れておくとよいでしょう。

### 文字列(Strings)

文字列（Strings）は、英訳通り文字の連続した列です。
文字列をリテラル、つまりテキスト文字として表示させるには「" " ダブルクォート」か、「' ' シングルクォート」で囲みます。
基本的には、シングルクォートとダブルクォートどちらも使っていいですが、スタイルガイドとして、基本全てシングルクォートを使うのが良いとされています。

例えば「Hello, world!」の文章を文字列リテラルとして表示させるには以下のように文字列を囲むことで、文字列リテラルとして表示させることができます。

```js
const phrase = 'Hello, world!';
console.log(phrase);// Hello, world! がアウトプットされる
```

しかし、引用符の「" "」や「' '」自体が文字列中に含まれている場合はどうなるのでしょうか？

結論から言うと、そのまま書くとうまく反映されない場合とされる場合とがあります。
うまく反映されない場合は、解決策として**エスケープ**を使います。

まずはダブルクォートやシングルクォートが文字列に含まれていても、反映される例を見てみましょう。

```js
const longPhrase = 'When I say "Hello, world!" in this way, it works.';
console.log(longPhrase);// When I say "Hello, world!" in this way, it works.がアウトプットされる

const sentence = "Even if I say 'Hello, world!' like this way, it also works.";
console.log(sentence);// Even if I say 'Hello, world!' like this way, it also works.がアウトプットされる
```

つまり、一番外で囲んでいるシングルクォートかダブルクォートに、文字列内に含まれるシングルクォートかダブルクォートが隣合わない限りは反映されるので、**エスケープ**する必要はありません。

今度は反映されない例を見てみましょう。

```js
const badPhrase = '"Hello, world!" to say like this is not going to work.';
console.log(badPhrase);// undefined がアプトプットされる

const badSentence = "Do you think this also works? 'Maybe, not.'";
console.log(badSentence);// undefined がアプトプットされる
```

`undefined`になるため、この場合は**エスケープ**する必要があります。
具体的には、**バックスラッシュ（\）**を入れます。

Macだと、**option + ¥**のキーでバックスラッシュは表示できます。

実際に視覚的に見た方が、バックスラッシュの入れ方の理解も早いので、エスケープさせた例を見てみましょう。

```js
const goodPhrase = '\"Hello, world!\" to say like this is not going to work.';
console.log(goodPhrase);// "Hello, world!" to say like this is not going to work.が反映される

const goodSentence = "Do you think this also works? \'Maybe, not.\'";
console.log(goodSentence);// Do you think this also works? 'Maybe, not.'が反映される
```

アポストロフィーにもエスケープは使用できます。
必要に応じてエスケープを使用してみましょう。

ここでは**エスケープ**を知っておくために解説してきましたが、ES6(ES2015) からは**_テンプレートリテラル_**と言う便利な方法が用意されていて、**バッククォート**を使用するとエスケープする必要がなくなります。

一部のブラウザは、まだ現時点ではES6未対応ですので、知識としてエスケープも**_テンプレートリテラル_**と合わせて知っておきましょう。

**_テンプレートリテラル_**はどちらかと言うと以下のような場合に活躍します。

```js
let currentStatus = 'student';
const phrase = `I'm a ${currentStatus}.`;

console.log(phrase);// I'm a student.がアプトプットされる
```

`${currentStatus}`は変数と呼ばれる値です。
**_テンプレートリテラル_**では、文字列の中に上記のような変数を含めることができます。

上記と同一の内容を`'I\'m a ' + currentStatus`と書くことも出来ますが、テンプレートリテラルがより可読性が高いため、文字列と文字列を含む変数を結合したい場合、テンプレートリテラルを使うのが推奨です。

また文字列全てにテンプレートリテラルを使うのではなく、通常はシングルクォート「''」を使い、変数がある場合のみテンプレートリテラルを使いましょう。

ところで、数字を文字列で表示させたい場合はどうしたら良いのでしょうか？

答えは非常に簡単で、シングルクォートやダブルクォートで囲まれた数字は文字列として認識されます。（※  厳密に言うと、認識される場合とされない場合とに分かれますが、データ型の変換と言う内容で詳細は学びます。）

文字列は実践でもよく使用します。
ここに挙げた基礎は、覚えておくと便利です。

### 論理値（真偽値、Boolean）

論理値は`true`もしくは`false`どちらかの値を取ります。英訳の通り、「真」か「偽」です。

JavaScriptでは数値以外も含めた全ての値を`true`か`false`として扱っています。
書き方に少し注意が必要で、`"false"`のようにダブルクォートで囲んでしまうと文字列として認識され、falseであっても`true`として処理されてしまうので、以下のように書きましょう。

```js
let shin = true;
let gi = false;
```

### null、undefined

`null`と`undefined`は、どちらも「存在しないもの」を表す「表現」です。
「存在しないもの」であれば表現できないのでは？と、思われたかもしれません。
ではなぜ「存在しないもの」を表現する必要があるのでしょうか？

答えは、JavaScriptの処理系のためには、存在しないものであっても表現する必要があるからです。

まだピンとこない答えかもしれませんが、要するに、何かしらの値として利用できるのが`null`です。

それに対し、`undefined`は値をまだ指定される前の状態の表現です。

開発者が変数などの値として利用したい時に使うことができる`データ型`としてであれば`null`が使えますが、`undefined`は値がそもそもまだ指定されていないことを表しているので、データ型としては使えないのです。

### シンボル

シンボル型はES6で新しく追加された型です。応用コースのレッスン7で学ぶためここでは触れません。