# レッスン2: 変数とデータ型

## 目的

- 変数、データ型の概念を理解する。

## データ型

全てのプログラミング言語には、その言語ごとの組み込みのデータ型があります。ES6の場合は全部で7種類があります。

この7つのデータ型は大きく分けて6つのプリミティブ(Primitive)型と1つのオブジェクト(Object)型に分けられます。

### プリミティブ型

プリミティブ(primitive)型は不変、つまり変わらない型という意味です。

具体的にプリミティブの値の不変性について例をあげると、テキスト文字（文字列）の"hello"と、"hello"と"world"が連結した"helloworld"は全く異なる値という事です。
数値だと数値の10と5の持つ意味は不変で 10 + 5 は常に15です。

以下は、6つのプリミティブ型の一覧です。

- 数値(Number)
- 文字列(String)
- 論理値(Boolean)
- Null
- Undefined
- シンボル(Symbol)

### オブジェクト型

プリミティブ型とことなりオブジェクト型は可変で、様々な形式や値をとる事ができ、カスタマイズされたデータ型として活用可能です。

以下の5つがオブジェクト型の代表的な例です。

- 配列(Array)
- 日時(Date)
- 正規表現(RegExp)
- マップ(Map)とウィークマップ(Weak Map)
- セット(Set)とウィークセット(Weak Set)

プリミティブ型とよく混乱しやすいのですが、先ほども述べたように、プリミティブ型の値は不変で、オブジェクトは可変と言うことに注目しましょう。

例えば、オブジェクト型である配列は数値も文字列も値として取る事ができます。

以下ではプリミティブ型、オブジェクト型について更に詳しくみていきましょう。

## プリミティブ型

### 数値(Number)

JavaScriptでは、もちろん計算もできます。
ただし全ての数字に関して計算が電卓で行ったように結果が出るかというと、実は「あること」が関係しているため、そうもいかないことがあります。

試しに以下の内容をGoogle developer tool を開いて、Consoleタブで計算してみましょう。

```js
const a = 0.1 + 0.2;
console.log(a);
```

単純に 0.1 + 0.2 の答えは電卓や暗算で行うと、もちろん 0.3 になるはずです。
ところが、JavaScriptの計算結果では以下のようになります。

```
0.30000000000000004
```

なぜでしょうか？
実はJavaScriptで適用される数値の表現は、**IEEE 754-2008**という**倍精度浮動小数点数（64ビット）**の表現を使用するために、計算結果が上記のようになるケースもあります。

もっと具体的に解説していきます。
数値の中にはコンピューターで表現できるものとできないもの（πなど）があるため、表現できないものは**近似値**で表現されます。
近似値で表現された数値の計算なので、組み合わせによって計算ミスのような結果が出る場合もあるのです。

別の例でいうと、πなどの無限にある桁数の数値と、限りのある有限の数値を計算することはできないので、コンピューターで表現できる近似値に無限にある数値を当てはめるため、こうしたことが起こります。

```
※  さらに踏み込むとJavaScriptは、他の言語と少し異なる点があり、整数と浮動小数点数を区別せず、全ての数値を浮動小数点数で表します。
```

そのため、JavaScriptは電卓アプリなど、整数演算や固定小数点数の精度が求められるアプリの開発には不向きだということがわかります。

特殊な例として、以下のような値も結果として返ってくる場合があります。

```js
console.log(1/0);// 計算結果 --> Infinity (無限大)
console.log(-1/0);// 計算結果 --> -Infinity（負の無限大）
console.log(Infinity/Infinity);// 計算結果 --> NaN（Not a numberの略）
```

計算結果としてこのような値が返ってくることもありますので、見慣れておくとよいでしょう。

### 文字列(Strings)

文字列（Strings）は、英訳通り文字の連続した列です。
文字列をリテラル、つまりテキスト文字として表示させるには「" " ダブルクォート」か、「' ' シングルクォート」で囲みます。
基本的には、シングルクォートとダブルクォートどちらも使っていいですが、スタイルガイドとして、基本全てシングルクォートを使うのが良いとされています。

例えば「Hello, world!」の文章を文字列リテラルとして表示させるには以下のように文字列を囲むことで、文字列リテラルとして表示させることができます。

```js
const phrase = 'Hello, world!';
console.log(phrase);// Hello, world! がアウトプットされる
```

しかし、引用符の「" "」や「' '」自体が文字列中に含まれている場合はどうなるのでしょうか？

結論から言うと、そのまま書くとうまく反映されない場合とされる場合とがあります。
うまく反映されない場合は、解決策として**エスケープ**を使います。

まずはダブルクォートやシングルクォートが文字列に含まれていても、反映される例を見てみましょう。

```js
const longPhrase = 'When I say "Hello, world!" in this way, it works.';
console.log(longPhrase);// When I say "Hello, world!" in this way, it works.がアウトプットされる

const sentence = "Even if I say 'Hello, world!' like this way, it also works.";
console.log(sentence);// Even if I say 'Hello, world!' like this way, it also works.がアウトプットされる
```

つまり、一番外で囲んでいるシングルクォートかダブルクォートに、文字列内に含まれるシングルクォートかダブルクォートが隣合わない限りは反映されるので、**エスケープ**する必要はありません。

今度は反映されない例を見てみましょう。

```js
const badPhrase = '"Hello, world!" to say like this is not going to work.';
console.log(badPhrase);// undefined がアプトプットされる

const badSentence = "Do you think this also works? 'Maybe, not.'";
console.log(badSentence);// undefined がアプトプットされる
```

`undefined`になるため、この場合は**エスケープ**する必要があります。
具体的には、**バックスラッシュ（\）**を入れます。

Macだと、**option + ¥**のキーでバックスラッシュは表示できます。

実際に視覚的に見た方が、バックスラッシュの入れ方の理解も早いので、エスケープさせた例を見てみましょう。

```js
const goodPhrase = '\"Hello, world!\" to say like this is not going to work.';
console.log(goodPhrase);// "Hello, world!" to say like this is not going to work.が反映される

const goodSentence = "Do you think this also works? \'Maybe, not.\'";
console.log(goodSentence);// Do you think this also works? 'Maybe, not.'が反映される
```

アポストロフィーにもエスケープは使用できます。
必要に応じてエスケープを使用してみましょう。

ここでは**エスケープ**を知っておくために解説してきましたが、ES6(ES2015) からは**_テンプレートリテラル_**と言う便利な方法が用意されていて、**バッククォート**を使用するとエスケープする必要がなくなります。

一部のブラウザは、まだ現時点ではES6未対応ですので、知識としてエスケープも**_テンプレートリテラル_**と合わせて知っておきましょう。

**_テンプレートリテラル_**はどちらかと言うと以下のような場合に活躍します。

```js
let currentStatus = 'student';
const phrase = `I'm a ${currentStatus}.`;

console.log(phrase);// I'm a student.がアプトプットされる
```

`${currentStatus}`は変数と呼ばれる値です。
**_テンプレートリテラル_**では、文字列の中に上記のような変数を含めることができます。

上記と同一の内容を`'I\'m a ' + currentStatus`と書くことも出来ますが、テンプレートリテラルがより可読性が高いため、文字列と文字列を含む変数を結合したい場合、テンプレートリテラルを使うのが推奨です。

また文字列全てにテンプレートリテラルを使うのではなく、通常はシングルクォート「''」を使い、変数がある場合のみテンプレートリテラルを使いましょう。

ところで、数字を文字列で表示させたい場合はどうしたら良いのでしょうか？

答えは非常に簡単で、シングルクォートやダブルクォートで囲まれた数字は文字列として認識されます。（※  厳密に言うと、認識される場合とされない場合とに分かれますが、データ型の変換と言う内容で詳細は学びます。）

文字列は実践でもよく使用します。
ここに挙げた基礎は、覚えておくと便利です。

### 論理値（真偽値、Boolean）

論理値は`true`もしくは`false`どちらかの値を取ります。英訳の通り、「真」か「偽」です。

JavaScriptでは数値以外も含めた全ての値を`true`か`false`として扱っています。
書き方に少し注意が必要で、`"false"`のようにダブルクォートで囲んでしまうと文字列として認識され、falseであっても`true`として処理されてしまうので、以下のように書きましょう。

```js
let shin = true;
let gi = false;
```

### null、undefined

`null`と`undefined`は、どちらも「存在しないもの」を表す「表現」です。
「存在しないもの」であれば表現できないのでは？と、思われたかもしれません。
ではなぜ「存在しないもの」を表現する必要があるのでしょうか？

答えは、JavaScriptの処理系のためには、存在しないものであっても表現する必要があるからです。

まだピンとこない答えかもしれませんが、要するに、何かしらの値として利用できるのが`null`です。

それに対し、`undefined`は値をまだ指定される前の状態の表現です。

開発者が変数などの値として利用したい時に使うことができる`データ型`としてであれば`null`が使えますが、`undefined`は値がそもそもまだ指定されていないことを表しているので、データ型としては使えないのです。

### シンボル

シンボル型はES6で新しく追加された型です。応用コースのレッスン7で学ぶためここでは触れません。

## オブジェクト型

### オブジェクト(Object)

プリミティブ型が不変であるのに対して、オブジェクト型は可変であるということを、このレッスンの冒頭でも述べました。

オブジェクトはいわゆる入れ物=箱のようなものであり、時間とともに中に入る内容物も変わって来ます。
入れ物としての箱は変わらず、箱の中身だけが時間や処理の進行に伴って変わっているイメージです。

その入れ物の中身の内容として、複数の値や複雑な値を入れておくことができるのです。

箱の中身がわかりやすいように、入れ物には中身の内容がわかるような名前をつけておくのが基本です。

オブジェクトがどんな役割をするのか、何となくイメージができたところで、実際にオブジェクトを使ってみましょう。
まずオブジェクトの書き方と構成について、簡単に記憶してから書いていきましょう。

入れ物の箱であるオブジェクトに記憶される内容物のことを**_プロパティ（property）_**と呼びます。
CSSにも出て来たので、CSSのプロパティとJavaScriptのプロパティを混同しないように気をつけましょう。
JavaScriptのプロパティは**名前(key)**と**値(value)**から成り立ち、プロパティの名前のことを**キー**と呼ぶこともあります。

キーとして使用できるのは文字列と、レッスン7で詳しく学ぶ方の1つ**_シンボル_**です。

試しに簡単に空のオブジェクトを作成して、プロパティに`color`を追加してみます。

```js
const obj = {};
obj.color = 'yellow';
console.log(obj.color);// yellowがアウトプットとして表示される
```

上記では`obj.color`というプロパティにアクセスするためのドット「.」を含める、**_メンバーアクセス演算子_**という方法を用いました。
この方法を用いることにより、プロパティ、つまり入れ物の箱であるオブジェクトの中身が何であるかを知ることができるのです。

実は、上記の方法は`obj.['color']`に書き換えても結果は同じになります。
どういうことかというと、「[]」（ブラケットと言います）で囲まれた部分を文字列で認識されます。
つまり、プロパティ名がスペースのように有効ではない名前であっても良いように文字列として認識するための方法です。
これを**計算値によるメンバーアクセス(computed member access)**と呼びます。

`color`のような有効な識別子のプロパティは、有効とみなされない識別子としての書き方でも、通常のメンバーアクセスの書き方でも認識されるというわけです。

ここまで空のオブジェクトを作ってみましたが、オブジェクトはプロパティの値を指定して生成することもできます。
簡単に構成を表記すると以下のようになります。

```js
const obj = {
  名前(文字列の場合はキー): '値',
  name: 'value',
};
```

上記の構成はオブジェクトのリテラル構文です。
上記の構成を覚えておいて、まず2つのオブジェクトを試しに生成してみます。

```js
const obj1 = {
  name: 'Lisa',
  nationality: 'Japanese',
};
console.log(obj1); // アウトプットは {name: "Lisa", nationality: "Japanese"}
console.log(obj1.name); // Lisaがアウトプットされる
console.log(obj1.nationality); // Japaneseがアウトプットされる

const obj2 = { name: 'Lisa', nationality: 'Japanese' }; // 1行で宣言 & 内容（プロパティ）はobj1と同じ
console.log(obj2); // アウトプットも同じ
console.log(obj1.name);
console.log(obj1.nationality);
```

 `obj1` と `obj2` はオブジェクトに穀される内容、つまりプロパティが同じでも、オブジェクトとしては全く別のものとして認識されることに注意しましょう。
 その証拠が以下の検証結果です。

 ```js
console.log(obj1.name === obj2.name); // true
console.log(obj1.nationality === obj2.nationality); // true
console.log(obj1 === obj2); // false
 ```

プロパティである、`name`と`nationality`は`obj1`も`obj2`も同じプロパティですが、`obj1`と`obj2`は異なるオブジェクトなので、詳しくはレッスン3の演算子の内容で学びますが、 `===` は、同じオブジェクであるか、プリミティブ型で、データ型も値も同じであるかどうかの全てが厳密に比較されるので、異なるオブジェクトのobj1とobj2は`obj1 === obj2`で`false`となった訳です。

オブジェクトの他の特徴の1つとして、オブジェクトは関数を持つことができ、以下のように使用することができます。
※　オブジェクトのプロパティとして使われる関数は、**_メソッド_**と言います。

```js
obj1.name = function() { return 'I\'m Lisa.' };
obj2.name = function() { return 'I\'m also Lisa, but a different one.' };

// 関数を呼び出すには、プロパティに()をつけて以下のように呼び出す。
console.log(obj1.name()); // I'm Lisa.
console.log(obj2.name()); // I'm also Lisa but a different one.
```

### 配列(Array)

配列（Array）は、オブジェクトと非常によく似ていおり、オブジェクトのように複数のデータを一度に処理するために存在する構造です。
詳しくはレッスン10で学びますが、ここでも少し概要を学んでおきましょう。

配列がオブジェクトと異なる点は、特別なタイプのオブジェクトとして扱われるため、配列に記憶されるデータには順番が決まっていて、キー（プロパティの名前）は0から始まる一連の整数です。
書き方も少し異なり、`[1, 2, 3, 4]`と、以下のように、配列要素を「[]」ブラケットで囲んで書きます。

```js
const arraySample = [1, 2, 3];
const randomType = [
  4,
  true,
  6,
  'seven',
  'ランダムな型も配列に含めることができます'
];
```

ランダムに異なる型も配列要素に含めることができるので、オブジェクトを配列要素にすることも、配列自体を配列要素にすることもできてしまいます。

```js
const objArray = [
  { name: 'Alex', age: 28 },
  { name: 'Samuel', age: 15 },
];

const arrayArray = [
  [0, 1, 2],
  [3, 4, 5, 6],
];
```

配列内に合計でいくつ要素があるかということも`length`を使用して返すことができます。
ただし、特定の要素にアクセスしたいときは、0から数える必要があるので、1番目の要素にアクセスしたい場合は以下のように書きます。

```js
const arraySample = [1, 2, 3];
console.log(arraySample.length); // 3
console.log(arraySample[0]); // 1

const objArray = [
  { name: 'Alex', age: 28 },
  { name: 'Samuel', age: 15 },
];
console.log(objArray[0].name); // Alex
console.log(objArray[1].age); // 15
```

特定要素にアクセスできることを利用して、以下のように特定の配列要素を書き換えることもできます。

```js
const swapArray = [
  'axela sedan',
  'Mazda',
  'pixis mega',
  'Toyota'
];

swapArray[0] = 'BMW';
swapArray[2] = 'Mercedes-Benz';
console.log(swapArray); // ['BMW', 'Mazda', 'Mercedes-Benz', 'Toyota']
console.log(swapArray.length); // 4
```

> ※　注意！
>
> 配列やオブジェクトの最終要素の後ろについている「,」は、データ交換で使用されるJSONでは禁止されていますが、配列やオブジェクトはInternet Explorerの古いバージョンを除いて「,」はエラーにならないのでつけても構いません。


### 日時(Date)

よく使用する日時の組み込みオブジェクトに`new Date()`があり、現在の日時を生成することができます。
実用面でまだまだ使い勝手が良いとは言えませんが、オブジェクトのプロパティとして使われる関数（メソッド）を使用すると私たちが普段馴染みのある年、月、日、時間をそれぞれに分けて取得することが可能です。

メソッドを使用しない場合と使用した場合とを見比べてみましょう。

```js
const now = new Date();
console.log(now); // Mon Apr 09 2018 23:55:53 GMT+0200 (CEST)

// ただしアウトプットは処理系によって異なる
```
上記はメソッドを使用しない例です。
それなりに整っているように上記では見えますが、これは処理系によるため、中には`2018-04-09T07:52:50.564Z`のようなアウトプット(これをISO表記と呼びます。)を返すものもあります。
上記に比べると処理系が異なるだけでこんなに表示の仕方が変わるので、特に見辛い表記が返される処理系の場合は困りますよね。

今度はメソッドを使用してみましょう。
```js
const now = new Date();

console.log(now.getFullYear()); // 2018
console.log(now.getMonth()); // 月は0からカウントされるため4月であれば「3」
console.log(now.getDate()); // 日も同様
console.log(now.getDay()); // 曜日も0（日曜日）、1（月曜日）...となる
```

この他にも`getHours()`、`getMinutes()`、`getSeconds()`、`getMilliseconds()`といったメソッドがあります。
`2018-04-09T07:52:50.564Z`のような表記よりは、0から曜日や月をカウントするとは言え、配列の特定要素へのアクセスと共通することなので、まだ私たちが普段馴染みある表記に近いアウトプットを返してくれます。

`new Date()`は使い勝手が良いとは言えないところもあり、実用的かと言われれば、難しいところがあります。そのため、**Moment.js**のようなライブラリを使用するのが、最近では主流です。

## チャレンジ

- [チャレンジ2](./challenge/README.md)

## 更に学ぼう

### 動画で学ぶ

- [JavaScript入門 - ドットインストール](https://dotinstall.com/lessons/basic_javascript_v2)

### 本で学ぶ

- [Eloquent JavaScript 3rd Edition](http://eloquentjavascript.net/)
